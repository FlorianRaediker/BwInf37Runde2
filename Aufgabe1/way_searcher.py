#!/usr/bin/env python3
"""
Geschrieben für die 2. Runde des 37. Bundeswettbewerb Informatik 2018
Autor: Florian Rädiker
Teilnahme-ID: 48302

Aufgabe 1: Lisa rennt

WRITTEN IN PYTHON3

Hauptbestandteil dieses Moduls ist die Klasse 'WaySearcher', die durch Rotational Plane Sweep und den Dijkstra-
Algorithmus den kürzesten Weg findet.
"""
from typing import List
import itertools

import os
import sys
cwd = os.path.dirname(__file__)  # current working directory
sys.path.append(cwd)  # find custom modules (geometry)
site_packages = os.path.join(cwd, "./site-packages/")  # site-packages directory
sys.path.append(site_packages)

from geometry import *

import svgwrite.shapes
import svgwrite.text
import svgwrite.container


class WaySearcher:
    def __init__(self, polygons: List[Polygon], lisa_node: Node, lisa_polygon: List[Point] = None,
                 bus_speed: float = 30/3.6, lisa_speed: float = 15/3.6):
        """
        Initializes a WaySearcher.
        :param edges: All the obstacle's edges in the area
        :param points: All the obstacle's vertices and Lisa's Node
        :param lisa_node: Node of Lisa's house
        :param bus_speed: Bus speed
        :param lisa_speed: Lisa's speed
        """
        self.polygons = polygons
        self.lisa_node = lisa_node
        self.lisa_polygon = lisa_polygon
        self.edges = list(itertools.chain(*(p.edges for p in self.polygons)))
        self.nodes = list(itertools.chain(*(p.points for p in self.polygons)))
        self.nodes.append(self.lisa_node)
        self.bus_speed = bus_speed
        self.lisa_speed = lisa_speed
        self.created_vis_graph = False  # set to True when visibility graph was generated by 'create_visibility_graph'
        self.vis_graph_lines = set()  # vis_graph_lines are only used for the svg graphic

    @staticmethod
    def from_str(text: str, bus_speed: float = 30/3.6, lisa_speed: float = 15/3.6) -> "WaySearcher":
        """
        Creates a new WaySearcher by the given string 'text' in the format described on the BwInf-Website.
        All lines starting with '#' are ignored, so you may use them as comments in your file.
        Additionally, the bus speed and Lisa's speed must be given as parameters so they can be given to the
        constructor.
        :param text: string in the format described on the BwInf-Website
        :param bus_speed: Optional. In meters per second. Standard: 30/3.6 m/s (30 km/h)
        :param lisa_speed: Optional. In meters per second. Standard: 15/3.6 m/s (15 km/h)
        :return: initialized WaySearcher-object
        """
        lines = [line for line in text.split("\n") if not line.startswith("#")]  # filter all lines with '#'
        numbers_last = [int(i) for i in lines[-1].split(" ")]
        lisa_node = Node(numbers_last[0], numbers_last[1], polygon_id="L")
        if len(numbers_last) > 2:
            lisa_polygon = [Point(
                int(numbers_last[i]) - lisa_node.x,
                int(numbers_last[i + 1]) - lisa_node.y
            ) for i in range(3, len(numbers_last), 2)]
            assert len(lisa_polygon) == int(numbers_last[2])
        else:
            lisa_polygon = None
        polygons = []
        for polygon_id, line in enumerate(lines[1:-1], 1):  # first line containing count of polygons is ignored
            polygons.append(Polygon.from_str(line, polygon_id, lisa_polygon))

        return WaySearcher(polygons, lisa_node, lisa_polygon, bus_speed, lisa_speed)

    def __repr__(self):
        return """WaySearcher(
\tpolygons = {polygons}
\tpoints = {nodes}
\tlisa_node = {lisa}
\tbus_speed = {v_bus}
\tlisa_speed = {v_lisa}
)""".format(polygons=self.polygons, nodes=self.nodes, lisa=self.lisa_node, v_bus=self.bus_speed, v_lisa=self.lisa_speed)

    def save_svg(self, filename: str, way: List[Point] = None, border: float = 50, labels: bool = False):
        """
        Saves this system as a svg graphic.
        :param filename: Path to file.
        :param way: If not None, all the points in 'way' are printed as well.
        :param border: border for the graphic in pixel
        :param labels: if True, labels are drawn for each point
        """
        group = svgwrite.container.Group()

        # calculate size
        size = (
            max(node.x for node in self.nodes) + border,
            max(node.y for node in self.nodes) + border  # the y-points are always 30° above the last obstacle
                                                         # vertex, so only y-points can have the greatest y-coordinate
        )
        for polygon in self.polygons:
            if polygon.small_polygons:
                group.add(svgwrite.shapes.Polygon((point.to_tuple() for point in polygon.original_points),
                                                  stroke="black", fill="yellow", stroke_width="2"))
                group.add(svgwrite.shapes.Polygon((point.to_tuple() for point in polygon.points),
                                                  stroke="black", fill="grey", fill_opacity="0.4", stroke_width="2"))
                for small in polygon.small_polygons:
                    group.add(svgwrite.shapes.Polygon((point.to_tuple() for point in small),
                                                      fill="grey", fill_opacity="0.7"))
            else:
                group.add(svgwrite.shapes.Polygon((point.to_tuple() for point in polygon.original_points),
                                                  stroke="black", fill="grey", stroke_width="2"))
        if labels:
            for node in self.nodes:
                group.add(svgwrite.text.Text("({pos[0]}|{pos[1]})"
                                              .format(pos=node.to_tuple()),
                                              node.to_tuple(),
                                              dy=["0.35em"], font_size="10", font_family="Arial",
                                              text_anchor="middle", fill="black"))
        for line in self.vis_graph_lines:
            group.add(
                svgwrite.shapes.Line(line.p1.to_tuple(), line.p2.to_tuple(), stroke="red", stroke_width="0.5")
            )
        # HOUSE
        group.add(
            svgwrite.shapes.Circle(self.lisa_node.to_tuple(), 10, fill="#F42121", stroke="#000080", stroke_width="1")
        )
        # WAY
        if way:
            group.add(
                svgwrite.shapes.Polyline((p.to_tuple() for p in way), fill="none", stroke="#000080", stroke_width="4")
            )
            if self.lisa_polygon:
                for point in way:
                    group.add(
                        svgwrite.shapes.Polygon((Point(vertex.x+point.x, vertex.y+point.y).to_tuple()
                                                 for vertex in self.lisa_polygon), fill="red", fill_opacity="0.5")
                    )
        if self.lisa_polygon:
            group.add(svgwrite.shapes.Polygon(
                (((self.lisa_node.x + point.x), (self.lisa_node.y + point.y)) for point in
                 self.lisa_polygon), fill="blue"))
        draw = svgwrite.Drawing(filename, size)
        draw.add(group)
        draw.save(True)

    def create_visibility_graph(self, check_overlapping_polygons=True):
        all_nodes = self.nodes.copy()
        if check_overlapping_polygons:
            nodes_outside_polygons = [point for point in self.nodes
                                                if point == self.lisa_node or not any(polygon.point_in_polygon(point)
                                                                                      for polygon in self.polygons
                                                                                          if polygon != point.polygon)]
        else:
            nodes_outside_polygons = all_nodes
        y_rotation_angle = math.degrees(math.asin(self.lisa_speed/self.bus_speed))
        for origin in nodes_outside_polygons:
            # do ROTATIONAL PLANE SWEEP for every node
            y_node = origin.get_rotated_on_y_axis(y_rotation_angle)

            lines = sorted((LineSegment(origin, point) for point in all_nodes + [y_node] if point != origin),
                           key=lambda segment: (segment.angle, segment.length))  # sort by segment.angle,
                                                                                 # if equal, sort by segment.length
            test_edges = set()  # all edges which must be tested with the current point
            # precalculate test_edges
            down = LineSegment(origin, Point(origin.x, 0))  # angle = 0° (start)
            for edge in self.edges:
                intersection = get_intersection(down, edge)
                # when there is an intersection, but the intersection lies exactly on one end of the edge, then the
                # x-coordinate must be greater than the intersection, because only in this case the edge will be
                # on the counter-clockwise side of the counter-clockwise rotating line and therefore be important.
                # Otherwise, the edge would cause irritation later (see the documentation for further details).
                if intersection is not None and \
                    ((not intersection.has_same_point(edge.p1) or intersection.x >= edge.p2.x) and
                     (not intersection.has_same_point(edge.p2) or intersection.x >= edge.p1.x)):
                    test_edges.add(edge)
            for line in lines:
                # check all relevant edges
                if line.p2 in nodes_outside_polygons or line.p2.x == 0:
                    for edge in test_edges:
                        if get_intersection(edge, line) is not None:
                            break  # there is an intersection
                    else:
                        if line.p1.polygon_id != line.p2.polygon_id or \
                            line.p1.polygon is None or line.p2.polygon is None or \
                            line.p2 in line.p1.polygon_neighbors or \
                            not line.p1.polygon.point_in_polygon(
                                Point((line.p1.x + line.p2.x) / 2, (line.p1.y + line.p2.y) / 2)):
                            # line.p2 is visible from origin because the loop did not break,
                            # so connect the two points and add the line to the visibility graph
                            line.p2.neighbors.append(line.p1)
                            self.vis_graph_lines.add(line)
                test_edges ^= line.p2.edges  # all edges which are in line.p2.edges and not in
                                             # test_edges are added, all others removed
            if y_node.neighbors:
                y_node.last_time = y_node.y / self.bus_speed
                self.nodes.append(y_node)
        self.created_vis_graph = True

    def dijkstra(self):
        if not self.created_vis_graph:
            raise ValueError("Visibility graph must be generated first. ")
        unvisited_nodes = self.nodes.copy()

        while unvisited_nodes:
            next_node = max(unvisited_nodes, key=lambda n: n.last_time)  # chose the Node with the best (latest) time
            if next_node == self.lisa_node:
                # chose Lisa's house, shortest path is found
                break
            unvisited_nodes.remove(next_node)
            for neighbor in next_node.neighbors:
                if neighbor in unvisited_nodes:  # visited Nodes already contain the best (latest) time
                    neighbor.reload_last_time(next_node, self.lisa_speed)
        else:
            # did not break, Lisa's house can not be reached
            raise ValueError("Lisa's house ('{}') is not reachable".format(self.lisa_node))
        # did break, so Lisa's house was found and is reachable, so calc the way backwards from self.lisa_node
        # by adding the parent
        way_points = []
        node = self.lisa_node
        length = 0
        while node is not None:
            way_points.append(node)
            if node.parent:
                length += node.get_distance(node.parent)
            node = node.parent
        return way_points, length, length/self.lisa_speed  # all points, length in meters, Lisa's time


if __name__ == "__main__":
    import sys
    import time
    import datetime
    
    assert len(sys.argv) == 3
    src = sys.argv[1]
    dst = sys.argv[2]
    with open(src, "r") as f:
        searcher = WaySearcher.from_str(f.read())
    t1_vis = time.perf_counter()
    searcher.create_visibility_graph()
    t2_vis = time.perf_counter()
    t1_dij = time.perf_counter()
    way, way_length, way_time = searcher.dijkstra()
    t2_dij = time.perf_counter()
    bus_time = way[-1].y / searcher.bus_speed
    print("""########
{name}
Vis. Graph time: {vis_time}
Dijkstra   time: {dij_time}""".format(name=src, vis_time=t2_vis - t1_vis, dij_time=t2_dij - t1_dij))
    if way[0].last_time == -math.inf:
        print("\nEs konnte kein Weg gefunden werden. ")
    else:
        print("""
Startzeit: {start_time.hour}:{start_time.minute:02}:{start_time.second:02} Uhr (abgerundet)
Zielzeit:  {y_time.hour}:{y_time.minute:02}:{y_time.second:02} Uhr (abgerundet)
y-Koord:   {y_bus:.0f}
Wegdauer:  {way_time.minute} Minuten {way_time.second} Sekunden (abgerundet)
Weglänge:  {way_length:.0f}m
WEG:
Starte beim Haus ({house.x}|{house.y}) (ID: 'L')""".format(
            start_time=datetime.datetime(100, 1, 1, hour=7, minute=30) +
                       datetime.timedelta(seconds=way[0].last_time),
            y_time=datetime.datetime(100, 1, 1, hour=7, minute=30) + datetime.timedelta(seconds=bus_time),
            y_bus=way[-1].y,
            way_time=datetime.datetime(100, 1, 1) + datetime.timedelta(seconds=way_time),
            way_length=way_length,
            house=way[0]
        )
        )
    for p in way[1:]:
        print("gehe zu ({way_point.x:3.0f}|{way_point.y:3.0f}) (ID: {id})"
              .format(way_point=p,
                      id="'P" + str(p.polygon_id) + "'" if p.polygon_id is not None else "keine (Endpunkt)"))
    print("\n")
    searcher.save_svg(dst, way)
